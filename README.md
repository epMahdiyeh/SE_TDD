![image](https://github.com/epMahdiyeh/SoftwareLab3/assets/62205305/742a2395-d516-44a4-a849-3898fa448a23)# SoftwareLab3

مرحله اول: محاسبه مساحت مستطیل

ابتدا با استفاده از کتابخانهJUnit تست‌های مربوط به محاسبه مساحت مستطیل را در کلاس RecTest می‌نویسیم:

در اینجا objectای از نوع Rectangle میسازیم و با استفاده از متد calculateArea مساحت این مستطیل را محاسبه میکنیم.

<img width="438" alt="1" src="https://github.com/epMahdiyeh/SoftwareLab3/assets/62205305/3f0e97bb-5a24-4db5-84d9-006aca882370">


بعد از ران کردن تست، به دلیل عدم وجود کلاس Rectangle با کامپایل ارور زیر مواجه میشویم:
<img width="857" alt="2" src="https://github.com/epMahdiyeh/SoftwareLab3/assets/62205305/f7d5d147-f08b-4df5-b31b-fedb7fac7ccd">


برای برطرف کردن این ارور، کلاس Rectangle را ساخته و سپس تست را مجددا ران میکنیم. (کلاس Rectangle جهت رعایت اصول SOLID (LSP, OCP) اینترفیس Type را implement میکند تا نیاز به ایجاد تغییرات مجدد نداشته باشیم)
<img width="440" alt="4" src="https://github.com/epMahdiyeh/SoftwareLab3/assets/62205305/09ef79f8-2ede-4550-9a79-d31b6caee7d5">
<img width="470" alt="3" src="https://github.com/epMahdiyeh/SoftwareLab3/assets/62205305/b11aa4b5-ba33-45f8-a8dc-ceb3223a65a8">


بعد از اجرای مجدد برنامه، با Runtime Error مواجه میشویم و پس از تغییر متد calculateArea تمامی تستها پاس خواهند شد:

<img width="542" alt="5" src="https://github.com/epMahdiyeh/SoftwareLab3/assets/62205305/967c8d76-69d9-40df-8ade-73e55bfc0dc1">
<img width="383" alt="6" src="https://github.com/epMahdiyeh/SoftwareLab3/assets/62205305/a2227f1f-38b6-414c-887d-cf3528c44bcd">
<img width="303" alt="7" src="https://github.com/epMahdiyeh/SoftwareLab3/assets/62205305/78a44d4d-7378-4c50-9a4f-bf629c749d96">

در مرحله بعد، باید برنامه را طوری تغییر دهیم که امکان تغییر طول و عرض مستطیل وجود داشته باشد. برای این کار از متدهای get و set استفاده میکنیم و پس از اجرای برنامه با ارور زیر مواجه میشویم:

<img width="277" alt="8" src="https://github.com/epMahdiyeh/SoftwareLab3/assets/62205305/8ff88ec2-121f-4169-b374-0de5e6c6f18b">
<img width="540" alt="9" src="https://github.com/epMahdiyeh/SoftwareLab3/assets/62205305/27b2ee13-1788-4f11-abcd-a6d692fb5fc7">

برای رفع این ارورها توابع set را در کلاس Rectangle اضافه کرده و اگر مجددا برنامه را اجرا کنیم خواهیم دید که تستها با موفقیت پاس میشوند:


<img width="291" alt="10" src="https://github.com/epMahdiyeh/SoftwareLab3/assets/62205305/a0b44e58-1a2d-4166-9419-73871cdd3786">

<img width="336" alt="11" src="https://github.com/epMahdiyeh/SoftwareLab3/assets/62205305/56f7784d-835c-4bbf-b48d-d5a71f62c75b">

در قدم آخر، از ما خواسته شده تا تغییرات را طوری در برنامه ایجاد کنیم که بتوان مساحت مربع را نیز علاوه بر مستطیل محاسبه کرد. مشابه مرحله قبل، ابتدا تستهای مربوط به محاسبه مساحت مربع را مینویسیم:

<img width="435" alt="12" src="https://github.com/epMahdiyeh/SoftwareLab3/assets/62205305/966b7e80-0249-4a50-93df-8127c4642ae9">

همانطور که انتظار میرود پس از اجرای تست با ارور مواجه میشویم و به شکل مشابه کلاس Square را پیاده سازی میکنیم:

<img width="674" alt="13" src="https://github.com/epMahdiyeh/SoftwareLab3/assets/62205305/71de021f-4dc6-4e68-867d-cfbddad6a7a3">

<img width="461" alt="14" src="https://github.com/epMahdiyeh/SoftwareLab3/assets/62205305/fad82a24-dee4-4378-91cc-9383cb983430">

حال با اجرای تست با خطای زمان اجرا مواجه شده و آن را با تغییر تابع calculateArea برطرف میکنیم:

<img width="699" alt="15" src="https://github.com/epMahdiyeh/SoftwareLab3/assets/62205305/2bc20846-3b0e-445f-aca7-17c93e42129c">

<img width="248" alt="16" src="https://github.com/epMahdiyeh/SoftwareLab3/assets/62205305/6afb5379-c5dd-4583-b749-6e49ef0a35e0">

تمامی تستها با موفقیت پاس شدند:

<img width="491" alt="17" src="https://github.com/epMahdiyeh/SoftwareLab3/assets/62205305/be5181ea-cd53-487a-8bd4-4f35bf8b64b7">

چک کردن اصول SOLID

SRP

کلاس‌های Rectangle و Square مسئول محاسبه مساحت مربع و مستطیل هستند، درحالی که کلاس Type مسئول تعریف متد   calculateArea  برای محاسبه مساحت هر شکل است.


LSP 

کلاس Square از کلاس Rectangle ارث بری نمیکند و به جای آن از   Typeارث‌ بری می‌کند.

ISP 

اینترفیس  Type با تعریف calculateArea که مسئولیت محاسبه مساحت را دارد، به کلاس‌هایی که آن را implement می‌کنند این امکان را میدهد تا فقط متدهای موردنیاز خود را استفاده کنند.


OCP 

پروژه برای توسعه open و برای تغییر close است؛ با تعریف قرارداد محاسبه مساحت در Type  و ایجاد پیاده‌سازی جدید‌، امکان افزودن اشکال جدید به پروژه بدون تغییر کد فعلی وجود دارد.

DIP

کلاس‌های مستطیل و مربع به Type وابسته هستند و این وابستگی به پروژه انعطاف و توسعه‌پذیری بیشتری می‌دهد.


--------------------------------------------------

پاسخ پرسش‌ها:

1. نه، این دو روش با یکدیگر تناقضی نیستند بلکه به چالش‌ های مختلف در فرآیند توسعه‌ی نرم‌افزار پاسخ میدهند. 
در چرخه‌ی عمومی توسعه نرم‌افزار، ابتدا پیاده‌سازی انجام می‌شود و سپس آزمون نرم‌افزار/تست برای اطمینان از صحت عملکرد نرم‌افزار اجرا میشود. این روش ممکن است منجر به کشف مشکلاتی شود که در مراحل پیشین پدیدار نشده ‌اند.
در روش TDD، ابتدا تست نوشته میشود و سپس کد مربوط به تست را پیاده ‌سازی میکنیم. این فرآیند چرخه‌ای است که تست‌ها و پیاده ‌سازی کد به صورت تناوبی انجام میشوند. درواقع این روش به توسعه ‌دهندگان کمک میکند تا کدی را بنویسند که از ابتدا به صورت قابل آزمون و قابل اطمینان باشد.
بنابراین، این دو روش به دو جنبه مختلف از یک مسئله نگاه می‌کنند و تضادی در آنها وجود ندارد. چرا که در هر دو حالت هدف نهایی اطمینان از صحت و عملکرد نرم‌ افزار است، اما روش TDD این کار را با نگاه به آزمون ‌پذیری و قابلیت تست کردن کد از ابتدا انجام میدهد.

2. آزمون‌های واحد به تست کردن بخش ‌های کوچکتر و ریزتری از کد میپردازند و معمولا به صورت مستقل از سایر بخش ‌های کد اجرا یشوند و هدف اصلی آنها اطمینان حاصل کردن از صحت و عملکرد صحیح قطعه‌ های کوچک کد است. طیف آزمون ‌ها بر اساس ریزدانگی می‌تواند به دو دسته تقسیم شود: آزمون‌های واحد با ریزدانگی درشت (coarse-grained) و آزمون‌های واحد با ریزدانگی ریز (fine-grained)

ریزدانگی درشت: آزمون های این دسته ممکن است شامل تست کلی بخشی از یک کلاس یا تابع باشد. به عنوان مثال، یک آزمون ممکن است ورودی‌ و خروجی ‌های یک تابع را بررسی کند، بدون اینکه به جزئیات داخلی تابع بپردازد.

ریزدانگی ریز: آزمون ‌های این دسته به صورت جزئی و ریزتری به قسمت‌ های مختلف یک کد مانند یک تابع یا متد میپردازند. این آزمون‌ ها ممکن است تست خط به خط کد یا شرایط مختلف اجرایی تابع را شامل شوند.

در کل، آزمون ‌های واحد با ریزدانگی درشت بیشتر برای اطمینان از ارتباط صحیح بین مؤلفه‌ های مختلف کد و تست کلی از نقاط ورودی و خروجی استفاده میکنند. در حالی که آزمون‌ های واحد با ریزدانگی ریز، توجه بیشتری به جزئیات و جریان اجرایی داخلی واحد مورد تست دارند و معمولا بر اساس تست کردن تک تک خطوط کد و شرایط ممکن استفاده میشوند. این تقسیم ‌بندی به توسعه‌ دهندگان کمک میکند تا استراتژی مناسبی برای آزمون واحد کد خود انتخاب کرده و اطمینان حاصل کنند که هر دو سطح ریزدانگی در فرآیند آزمون پوشش داده شده‌ اند.

3. خیر، لزوما همه‌ انواع آزمون‌های نرم ‌افزار توسط برنامه ‌نویسان ‌بوجود نمی‌ آیند. آزمون ‌های نرم ‌افزار توسط یک تیم تخصصی از فردی که ممکن است برنامه‌ نویس باشد ولی معمولا از دامنه‌ های مختلفی مثل testerها یا QA engineerها نیز تشکیل شده و توسعه دهندگان تنها بخشی از این تیم هستند. در فرآیند توسعه نرم‌ افزار، تیم‌ های مختلف مسئولیتهای مختلفی دارند. بطوریکه برنامه نویسان به تولید کد، توسعه و تست واحد (unit testing) مسئولند. اما testerها به آزمون و اعتبارسنجی کلیه‌ عملکردها و ویژگی‌ های نرم‌ افزار از جمله تست نهایی (end-to-end testing) و تستهای عملکردی (performance testing) نیز مسئولند.

4. اصول SOLID اصولی هستند که در طراحی و پیاده‌ سازی نرم ‌افزار به کار میروند. در مرحله طراحی، از SRP برای تعیین مسئولیت‌ ها، OCP برای افزودن ویژگی ‌ها بدون تغییر کد موجود، LSP برای ایجاد اشیاء جایگزین و قابل تعویض، و ISP برای طراحی اینترفیس های کوچک و مجزا استفاده میشود. در مرحله پیاده‌ سازی، از DIP برای مدیریت وابستگی ‌ها و استفاده از وابسته‌ سازیها به کلاسها استفاده میشود.
این اصول باعث ایجاد کدی متمرکز، قابل نگهداری و قابل توسعه می‌ شوند. با رعایت این اصول، کد نرم ‌افزار به راحتی قابل تغییر، تست و انعطاف خواهد بود. در فرآیند پیاده ‌سازی، اصول SOLID به عنوان راهنمایی کاربردی برای مدیریت فرآیند ایجاد کلاس‌ ها و توابع جداگانه مورد استفاده قرار می ‌گیرند، تا اطمینان حاصل شود که این عناصر منسجم باشند و به آسانی روی آنها آزمون/تست انجام شود. درواقع به کاربرد اصول SOLID برای شناسایی و حذف نقاط ضعف کد، مثل couplingو ایجاد یک ساختار کد که قابلیت گسترش و نگهداری داشته باشد پرداخته میشود.


5. بله. اگر نیازی به تغییر ابعاد مستطیل و مربع نداشته باشیم میتوان کلاس Square را طوری پیاده سازی کرد که از Rectangle  ارث بری کند. درواقع مربع نوعی مستطیل است و اگر قابلیتی داشته باشیم که عرض و ارتفاع آن همیشه یکسان باشند مسئله حل میشود. برای این کار میتوانیم متد سازنده کلاس Square  را با گرفتن یک ورودی بعنوان ضلع پیاده سازی کنیم و این ارگومان را به متد سازنده کلاس Rectangle  بدهیم. کد زیر نوعی از این پیاده سازی است:
   
```
  public class Square extends Rectangle {
    public Square(double side) {
        super(side, side);
    }
}
```



